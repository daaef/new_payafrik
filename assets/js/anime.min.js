/*
 * anime.js v3.2.0
 * (c) 2020 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

!(function (n, e) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = e())
    : typeof define === 'function' && define.amd
    ? define(e)
    : (n.anime = e())
})(this, function () {
  'use strict'
  const n = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: 'normal',
    autoplay: !0,
    timelineOffset: 0,
  }
  const e = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    easing: 'easeOutElastic(1, .5)',
    round: 0,
  }
  const r = [
    'translateX',
    'translateY',
    'translateZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'skew',
    'skewX',
    'skewY',
    'perspective',
    'matrix',
    'matrix3d',
  ]
  const t = { CSS: {}, springs: {} }
  function a(n, e, r) {
    return Math.min(Math.max(n, e), r)
  }
  function o(n, e) {
    return n.includes(e)
  }
  function u(n, e) {
    return n.apply(null, e)
  }
  var i = {
    arr(n) {
      return Array.isArray(n)
    },
    obj(n) {
      return o(Object.prototype.toString.call(n), 'Object')
    },
    pth(n) {
      return i.obj(n) && n.hasOwnProperty('totalLength')
    },
    svg(n) {
      return n instanceof SVGElement
    },
    inp(n) {
      return n instanceof HTMLInputElement
    },
    dom(n) {
      return n.nodeType || i.svg(n)
    },
    str(n) {
      return typeof n === 'string'
    },
    fnc(n) {
      return typeof n === 'function'
    },
    und(n) {
      return void 0 === n
    },
    hex(n) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(n)
    },
    rgb(n) {
      return n.startsWith('rgb')
    },
    hsl(n) {
      return n.startsWith('hsl')
    },
    col(n) {
      return i.hex(n) || i.rgb(n) || i.hsl(n)
    },
    key(r) {
      return (
        !n.hasOwnProperty(r) &&
        !e.hasOwnProperty(r) &&
        r !== 'targets' &&
        r !== 'keyframes'
      )
    },
  }
  function c(n) {
    const e = /\(([^)]+)\)/.exec(n)
    return e
      ? e[1].split(',').map(function (n) {
          return parseFloat(n)
        })
      : []
  }
  function s(n, e) {
    const r = c(n)
    const o = a(i.und(r[0]) ? 1 : r[0], 0.1, 100)
    const u = a(i.und(r[1]) ? 100 : r[1], 0.1, 100)
    const s = a(i.und(r[2]) ? 10 : r[2], 0.1, 100)
    const f = a(i.und(r[3]) ? 0 : r[3], 0.1, 100)
    const l = Math.sqrt(u / o)
    const d = s / (2 * Math.sqrt(u * o))
    const p = d < 1 ? l * Math.sqrt(1 - d * d) : 0
    const h = 1
    const v = d < 1 ? (d * l - f) / p : -f + l
    function g(n) {
      let r = e ? (e * n) / 1e3 : n
      return (
        (r =
          d < 1
            ? Math.exp(-r * d * l) * (h * Math.cos(p * r) + v * Math.sin(p * r))
            : (h + v * r) * Math.exp(-r * l)),
        n === 0 || n === 1 ? n : 1 - r
      )
    }
    return e
      ? g
      : function () {
          const e = t.springs[n]
          if (e) return e
          for (var r = 0, a = 0; ; )
            if (g((r += 1 / 6)) === 1) {
              if (++a >= 16) break
            } else a = 0
          const o = r * (1 / 6) * 1e3
          return (t.springs[n] = o), o
        }
  }
  function f(n) {
    return (
      void 0 === n && (n = 10),
      function (e) {
        return Math.ceil(a(e, 1e-6, 1) * n) * (1 / n)
      }
    )
  }
  let l
  let d
  const p = (function () {
    const n = 11
    const e = 1 / (n - 1)
    function r(n, e) {
      return 1 - 3 * e + 3 * n
    }
    function t(n, e) {
      return 3 * e - 6 * n
    }
    function a(n) {
      return 3 * n
    }
    function o(n, e, o) {
      return ((r(e, o) * n + t(e, o)) * n + a(e)) * n
    }
    function u(n, e, o) {
      return 3 * r(e, o) * n * n + 2 * t(e, o) * n + a(e)
    }
    return function (r, t, a, i) {
      if (r >= 0 && r <= 1 && a >= 0 && a <= 1) {
        var c = new Float32Array(n)
        if (r !== t || a !== i)
          for (let s = 0; s < n; ++s) c[s] = o(s * e, r, a)
        return function (n) {
          return r === t && a === i ? n : n === 0 || n === 1 ? n : o(f(n), t, i)
        }
      }
      function f(t) {
        for (var i = 0, s = 1, f = n - 1; s !== f && c[s] <= t; ++s) i += e
        const l = i + ((t - c[--s]) / (c[s + 1] - c[s])) * e
        const d = u(l, r, a)
        return d >= 0.001
          ? (function (n, e, r, t) {
              for (let a = 0; a < 4; ++a) {
                const i = u(e, r, t)
                if (i === 0) return e
                e -= (o(e, r, t) - n) / i
              }
              return e
            })(t, l, r, a)
          : d === 0
          ? l
          : (function (n, e, r, t, a) {
              for (
                var u, i, c = 0;
                (u = o((i = e + (r - e) / 2), t, a) - n) > 0
                  ? (r = i)
                  : (e = i),
                  Math.abs(u) > 1e-7 && ++c < 10;

              );
              return i
            })(t, i, i + e, r, a)
      }
    }
  })()
  const h =
    ((l = {
      linear() {
        return function (n) {
          return n
        }
      },
    }),
    (d = {
      Sine() {
        return function (n) {
          return 1 - Math.cos((n * Math.PI) / 2)
        }
      },
      Circ() {
        return function (n) {
          return 1 - Math.sqrt(1 - n * n)
        }
      },
      Back() {
        return function (n) {
          return n * n * (3 * n - 2)
        }
      },
      Bounce() {
        return function (n) {
          for (var e, r = 4; n < ((e = Math.pow(2, --r)) - 1) / 11; );
          return (
            1 / Math.pow(4, 3 - r) - 7.5625 * Math.pow((3 * e - 2) / 22 - n, 2)
          )
        }
      },
      Elastic(n, e) {
        void 0 === n && (n = 1), void 0 === e && (e = 0.5)
        const r = a(n, 1, 10)
        const t = a(e, 0.1, 2)
        return function (n) {
          return n === 0 || n === 1
            ? n
            : -r *
                Math.pow(2, 10 * (n - 1)) *
                Math.sin(
                  ((n - 1 - (t / (2 * Math.PI)) * Math.asin(1 / r)) *
                    (2 * Math.PI)) /
                    t
                )
        }
      },
    }),
    ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'].forEach(function (n, e) {
      d[n] = function () {
        return function (n) {
          return Math.pow(n, e + 2)
        }
      }
    }),
    Object.keys(d).forEach(function (n) {
      const e = d[n]
      ;(l['easeIn' + n] = e),
        (l['easeOut' + n] = function (n, r) {
          return function (t) {
            return 1 - e(n, r)(1 - t)
          }
        }),
        (l['easeInOut' + n] = function (n, r) {
          return function (t) {
            return t < 0.5 ? e(n, r)(2 * t) / 2 : 1 - e(n, r)(-2 * t + 2) / 2
          }
        })
    }),
    l)
  function v(n, e) {
    if (i.fnc(n)) return n
    const r = n.split('(')[0]
    const t = h[r]
    const a = c(n)
    switch (r) {
      case 'spring':
        return s(n, e)
      case 'cubicBezier':
        return u(p, a)
      case 'steps':
        return u(f, a)
      default:
        return u(t, a)
    }
  }
  function g(n) {
    try {
      return document.querySelectorAll(n)
    } catch (n) {}
  }
  function m(n, e) {
    for (
      var r = n.length,
        t = arguments.length >= 2 ? arguments[1] : void 0,
        a = [],
        o = 0;
      o < r;
      o++
    )
      if (o in n) {
        const u = n[o]
        e.call(t, u, o, n) && a.push(u)
      }
    return a
  }
  function y(n) {
    return n.reduce(function (n, e) {
      return n.concat(i.arr(e) ? y(e) : e)
    }, [])
  }
  function b(n) {
    return i.arr(n)
      ? n
      : (i.str(n) && (n = g(n) || n),
        n instanceof NodeList || n instanceof HTMLCollection
          ? [].slice.call(n)
          : [n])
  }
  function x(n, e) {
    return n.some(function (n) {
      return n === e
    })
  }
  function M(n) {
    const e = {}
    for (const r in n) e[r] = n[r]
    return e
  }
  function w(n, e) {
    const r = M(n)
    for (const t in n) r[t] = e.hasOwnProperty(t) ? e[t] : n[t]
    return r
  }
  function k(n, e) {
    const r = M(n)
    for (const t in e) r[t] = i.und(n[t]) ? e[t] : n[t]
    return r
  }
  function O(n) {
    return i.rgb(n)
      ? (r = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec((e = n)))
        ? 'rgba(' + r[1] + ',1)'
        : e
      : i.hex(n)
      ? ((t = n.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (
          n,
          e,
          r,
          t
        ) {
          return e + e + r + r + t + t
        })),
        (a = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t)),
        'rgba(' +
          parseInt(a[1], 16) +
          ',' +
          parseInt(a[2], 16) +
          ',' +
          parseInt(a[3], 16) +
          ',1)')
      : i.hsl(n)
      ? (function (n) {
          let e
          let r
          let t
          const a =
            /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(n) ||
            /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(n)
          const o = parseInt(a[1], 10) / 360
          const u = parseInt(a[2], 10) / 100
          const i = parseInt(a[3], 10) / 100
          const c = a[4] || 1
          function s(n, e, r) {
            return (
              r < 0 && (r += 1),
              r > 1 && (r -= 1),
              r < 1 / 6
                ? n + 6 * (e - n) * r
                : r < 0.5
                ? e
                : r < 2 / 3
                ? n + (e - n) * (2 / 3 - r) * 6
                : n
            )
          }
          if (u == 0) e = r = t = i
          else {
            const f = i < 0.5 ? i * (1 + u) : i + u - i * u
            const l = 2 * i - f
            ;(e = s(l, f, o + 1 / 3)),
              (r = s(l, f, o)),
              (t = s(l, f, o - 1 / 3))
          }
          return (
            'rgba(' + 255 * e + ',' + 255 * r + ',' + 255 * t + ',' + c + ')'
          )
        })(n)
      : void 0
    let e, r, t, a
  }
  function C(n) {
    const e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
      n
    )
    if (e) return e[1]
  }
  function B(n, e) {
    return i.fnc(n) ? n(e.target, e.id, e.total) : n
  }
  function P(n, e) {
    return n.getAttribute(e)
  }
  function I(n, e, r) {
    if (x([r, 'deg', 'rad', 'turn'], C(e))) return e
    const a = t.CSS[e + r]
    if (!i.und(a)) return a
    const o = document.createElement(n.tagName)
    const u =
      n.parentNode && n.parentNode !== document ? n.parentNode : document.body
    u.appendChild(o), (o.style.position = 'absolute'), (o.style.width = 100 + r)
    const c = 100 / o.offsetWidth
    u.removeChild(o)
    const s = c * parseFloat(e)
    return (t.CSS[e + r] = s), s
  }
  function T(n, e, r) {
    if (e in n.style) {
      const t = e.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
      const a = n.style[e] || getComputedStyle(n).getPropertyValue(t) || '0'
      return r ? I(n, a, r) : a
    }
  }
  function D(n, e) {
    return i.dom(n) && !i.inp(n) && (P(n, e) || (i.svg(n) && n[e]))
      ? 'attribute'
      : i.dom(n) && x(r, e)
      ? 'transform'
      : i.dom(n) && e !== 'transform' && T(n, e)
      ? 'css'
      : n[e] != null
      ? 'object'
      : void 0
  }
  function E(n) {
    if (i.dom(n)) {
      for (
        var e,
          r = n.style.transform || '',
          t = /(\w+)\(([^)]*)\)/g,
          a = new Map();
        (e = t.exec(r));

      )
        a.set(e[1], e[2])
      return a
    }
  }
  function F(n, e, r, t) {
    let a
    const u = o(e, 'scale')
      ? 1
      : 0 +
        (o((a = e), 'translate') || a === 'perspective'
          ? 'px'
          : o(a, 'rotate') || o(a, 'skew')
          ? 'deg'
          : void 0)
    const i = E(n).get(e) || u
    return (
      r && (r.transforms.list.set(e, i), (r.transforms.last = e)),
      t ? I(n, i, t) : i
    )
  }
  function N(n, e, r, t) {
    switch (D(n, e)) {
      case 'transform':
        return F(n, e, t, r)
      case 'css':
        return T(n, e, r)
      case 'attribute':
        return P(n, e)
      default:
        return n[e] || 0
    }
  }
  function A(n, e) {
    const r = /^(\*=|\+=|-=)/.exec(n)
    if (!r) return n
    const t = C(n) || 0
    const a = parseFloat(e)
    const o = parseFloat(n.replace(r[0], ''))
    switch (r[0][0]) {
      case '+':
        return a + o + t
      case '-':
        return a - o + t
      case '*':
        return a * o + t
    }
  }
  function L(n, e) {
    if (i.col(n)) return O(n)
    if (/\s/g.test(n)) return n
    const r = C(n)
    const t = r ? n.substr(0, n.length - r.length) : n
    return e ? t + e : t
  }
  function j(n, e) {
    return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
  }
  function S(n) {
    for (var e, r = n.points, t = 0, a = 0; a < r.numberOfItems; a++) {
      const o = r.getItem(a)
      a > 0 && (t += j(e, o)), (e = o)
    }
    return t
  }
  function q(n) {
    if (n.getTotalLength) return n.getTotalLength()
    switch (n.tagName.toLowerCase()) {
      case 'circle':
        return (o = n), 2 * Math.PI * P(o, 'r')
      case 'rect':
        return 2 * P((a = n), 'width') + 2 * P(a, 'height')
      case 'line':
        return j(
          { x: P((t = n), 'x1'), y: P(t, 'y1') },
          { x: P(t, 'x2'), y: P(t, 'y2') }
        )
      case 'polyline':
        return S(n)
      case 'polygon':
        return (
          (r = (e = n).points),
          S(e) + j(r.getItem(r.numberOfItems - 1), r.getItem(0))
        )
    }
    let e, r, t, a, o
  }
  function $(n, e) {
    const r = e || {}
    const t =
      r.el ||
      (function (n) {
        for (var e = n.parentNode; i.svg(e) && i.svg(e.parentNode); )
          e = e.parentNode
        return e
      })(n)
    const a = t.getBoundingClientRect()
    const o = P(t, 'viewBox')
    const u = a.width
    const c = a.height
    const s = r.viewBox || (o ? o.split(' ') : [0, 0, u, c])
    return {
      el: t,
      viewBox: s,
      x: s[0] / 1,
      y: s[1] / 1,
      w: u / s[2],
      h: c / s[3],
    }
  }
  function X(n, e) {
    function r(r) {
      void 0 === r && (r = 0)
      const t = e + r >= 1 ? e + r : 0
      return n.el.getPointAtLength(t)
    }
    const t = $(n.el, n.svg)
    const a = r()
    const o = r(-1)
    const u = r(1)
    switch (n.property) {
      case 'x':
        return (a.x - t.x) * t.w
      case 'y':
        return (a.y - t.y) * t.h
      case 'angle':
        return (180 * Math.atan2(u.y - o.y, u.x - o.x)) / Math.PI
    }
  }
  function Y(n, e) {
    const r = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g
    const t = L(i.pth(n) ? n.totalLength : n, e) + ''
    return {
      original: t,
      numbers: t.match(r) ? t.match(r).map(Number) : [0],
      strings: i.str(n) || e ? t.split(r) : [],
    }
  }
  function Z(n) {
    return m(n ? y(i.arr(n) ? n.map(b) : b(n)) : [], function (n, e, r) {
      return r.indexOf(n) === e
    })
  }
  function Q(n) {
    const e = Z(n)
    return e.map(function (n, r) {
      return { target: n, id: r, total: e.length, transforms: { list: E(n) } }
    })
  }
  function V(n, e) {
    const r = M(e)
    if (
      (r.easing.startsWith('spring') && (r.duration = s(r.easing)), i.arr(n))
    ) {
      const t = n.length
      t === 2 && !i.obj(n[0])
        ? (n = { value: n })
        : i.fnc(e.duration) || (r.duration = e.duration / t)
    }
    const a = i.arr(n) ? n : [n]
    return a
      .map(function (n, r) {
        const t = i.obj(n) && !i.pth(n) ? n : { value: n }
        return (
          i.und(t.delay) && (t.delay = r ? 0 : e.delay),
          i.und(t.endDelay) &&
            (t.endDelay = r === a.length - 1 ? e.endDelay : 0),
          t
        )
      })
      .map(function (n) {
        return k(n, r)
      })
  }
  function z(n, e) {
    const r = []
    const t = e.keyframes
    for (const a in (t &&
      (e = k(
        (function (n) {
          for (
            var e = m(
                y(
                  n.map(function (n) {
                    return Object.keys(n)
                  })
                ),
                function (n) {
                  return i.key(n)
                }
              ).reduce(function (n, e) {
                return !n.includes(e) && n.push(e), n
              }, []),
              r = {},
              t = function (t) {
                const a = e[t]
                r[a] = n.map(function (n) {
                  const e = {}
                  for (const r in n)
                    i.key(r) ? r == a && (e.value = n[r]) : (e[r] = n[r])
                  return e
                })
              },
              a = 0;
            a < e.length;
            a++
          )
            t(a)
          return r
        })(t),
        e
      )),
    e))
      i.key(a) && r.push({ name: a, tweens: V(e[a], n) })
    return r
  }
  function H(n, e) {
    let r
    return n.tweens.map(function (t) {
      const a = (function (n, e) {
        const r = {}
        for (const t in n) {
          let a = B(n[t], e)
          i.arr(a) &&
            (a = a.map(function (n) {
              return B(n, e)
            })).length === 1 &&
            (a = a[0]),
            (r[t] = a)
        }
        return (
          (r.duration = parseFloat(r.duration)),
          (r.delay = parseFloat(r.delay)),
          r
        )
      })(t, e)
      const o = a.value
      let u = i.arr(o) ? o[1] : o
      const c = C(u)
      const s = N(e.target, n.name, c, e)
      const f = r ? r.to.original : s
      const l = i.arr(o) ? o[0] : f
      const d = C(l) || C(s)
      const p = c || d
      return (
        i.und(u) && (u = f),
        (a.from = Y(l, p)),
        (a.to = Y(A(u, l), p)),
        (a.start = r ? r.end : 0),
        (a.end = a.start + a.delay + a.duration + a.endDelay),
        (a.easing = v(a.easing, a.duration)),
        (a.isPath = i.pth(o)),
        (a.isColor = i.col(a.from.original)),
        a.isColor && (a.round = 1),
        (r = a),
        a
      )
    })
  }
  const G = {
    css(n, e, r) {
      return (n.style[e] = r)
    },
    attribute(n, e, r) {
      return n.setAttribute(e, r)
    },
    object(n, e, r) {
      return (n[e] = r)
    },
    transform(n, e, r, t, a) {
      if ((t.list.set(e, r), e === t.last || a)) {
        let o = ''
        t.list.forEach(function (n, e) {
          o += e + '(' + n + ') '
        }),
          (n.style.transform = o)
      }
    },
  }
  function R(n, e) {
    Q(n).forEach(function (n) {
      for (const r in e) {
        const t = B(e[r], n)
        const a = n.target
        const o = C(t)
        const u = N(a, r, o, n)
        const i = A(L(t, o || C(u)), u)
        const c = D(a, r)
        G[c](a, r, i, n.transforms, !0)
      }
    })
  }
  function W(n, e) {
    return m(
      y(
        n.map(function (n) {
          return e.map(function (e) {
            return (function (n, e) {
              const r = D(n.target, e.name)
              if (r) {
                const t = H(e, n)
                const a = t[t.length - 1]
                return {
                  type: r,
                  property: e.name,
                  animatable: n,
                  tweens: t,
                  duration: a.end,
                  delay: t[0].delay,
                  endDelay: a.endDelay,
                }
              }
            })(n, e)
          })
        })
      ),
      function (n) {
        return !i.und(n)
      }
    )
  }
  function J(n, e) {
    const r = n.length
    const t = function (n) {
      return n.timelineOffset ? n.timelineOffset : 0
    }
    const a = {}
    return (
      (a.duration = r
        ? Math.max.apply(
            Math,
            n.map(function (n) {
              return t(n) + n.duration
            })
          )
        : e.duration),
      (a.delay = r
        ? Math.min.apply(
            Math,
            n.map(function (n) {
              return t(n) + n.delay
            })
          )
        : e.delay),
      (a.endDelay = r
        ? a.duration -
          Math.max.apply(
            Math,
            n.map(function (n) {
              return t(n) + n.duration - n.endDelay
            })
          )
        : e.endDelay),
      a
    )
  }
  let K = 0
  let U
  let _ = []
  let nn = []
  const en = (function () {
    function n() {
      U = requestAnimationFrame(e)
    }
    function e(e) {
      let r = _.length
      if (r) {
        for (let t = 0; t < r; ) {
          const a = _[t]
          if (a.paused) {
            const o = _.indexOf(a)
            o > -1 && (_.splice(o, 1), (r = _.length))
          } else a.tick(e)
          t++
        }
        n()
      } else U = cancelAnimationFrame(U)
    }
    return n
  })()
  function rn(r) {
    void 0 === r && (r = {})
    let t
    let o = 0
    let u = 0
    let i = 0
    let c = 0
    let s = null
    function f(n) {
      const e =
        window.Promise &&
        new Promise(function (n) {
          return (s = n)
        })
      return (n.finished = e), e
    }
    let l
    let d
    let p
    let h
    let v
    let g
    let y
    let b
    const x =
      ((d = w(n, (l = r))),
      (p = w(e, l)),
      (h = z(p, l)),
      (v = Q(l.targets)),
      (g = W(v, h)),
      (y = J(g, p)),
      (b = K),
      K++,
      k(d, {
        id: b,
        children: [],
        animatables: v,
        animations: g,
        duration: y.duration,
        delay: y.delay,
        endDelay: y.endDelay,
      }))
    f(x)
    function M() {
      const n = x.direction
      n !== 'alternate' &&
        (x.direction = n !== 'normal' ? 'normal' : 'reverse'),
        (x.reversed = !x.reversed),
        t.forEach(function (n) {
          return (n.reversed = x.reversed)
        })
    }
    function O(n) {
      return x.reversed ? x.duration - n : n
    }
    function C() {
      ;(o = 0), (u = O(x.currentTime) * (1 / rn.speed))
    }
    function B(n, e) {
      e && e.seek(n - e.timelineOffset)
    }
    function P(n) {
      for (let e = 0, r = x.animations, t = r.length; e < t; ) {
        const o = r[e]
        const u = o.animatable
        const i = o.tweens
        const c = i.length - 1
        let s = i[c]
        c &&
          (s =
            m(i, function (e) {
              return n < e.end
            })[0] || s)
        for (
          var f = a(n - s.start - s.delay, 0, s.duration) / s.duration,
            l = isNaN(f) ? 1 : s.easing(f),
            d = s.to.strings,
            p = s.round,
            h = [],
            v = s.to.numbers.length,
            g = void 0,
            y = 0;
          y < v;
          y++
        ) {
          let b = void 0
          const M = s.to.numbers[y]
          const w = s.from.numbers[y] || 0
          ;(b = s.isPath ? X(s.value, l * M) : w + l * (M - w)),
            p && ((s.isColor && y > 2) || (b = Math.round(b * p) / p)),
            h.push(b)
        }
        const k = d.length
        if (k) {
          g = d[0]
          for (let O = 0; O < k; O++) {
            d[O]
            const C = d[O + 1]
            const B = h[O]
            isNaN(B) || (g += C ? B + C : B + ' ')
          }
        } else g = h[0]
        G[o.type](u.target, o.property, g, u.transforms),
          (o.currentValue = g),
          e++
      }
    }
    function I(n) {
      x[n] && !x.passThrough && x[n](x)
    }
    function T(n) {
      const e = x.duration
      const r = x.delay
      const l = e - x.endDelay
      const d = O(n)
      ;(x.progress = a((d / e) * 100, 0, 100)),
        (x.reversePlayback = d < x.currentTime),
        t &&
          (function (n) {
            if (x.reversePlayback) for (let e = c; e--; ) B(n, t[e])
            else for (let r = 0; r < c; r++) B(n, t[r])
          })(d),
        !x.began && x.currentTime > 0 && ((x.began = !0), I('begin')),
        !x.loopBegan &&
          x.currentTime > 0 &&
          ((x.loopBegan = !0), I('loopBegin')),
        d <= r && x.currentTime !== 0 && P(0),
        ((d >= l && x.currentTime !== e) || !e) && P(e),
        d > r && d < l
          ? (x.changeBegan ||
              ((x.changeBegan = !0),
              (x.changeCompleted = !1),
              I('changeBegin')),
            I('change'),
            P(d))
          : x.changeBegan &&
            ((x.changeCompleted = !0),
            (x.changeBegan = !1),
            I('changeComplete')),
        (x.currentTime = a(d, 0, e)),
        x.began && I('update'),
        n >= e &&
          ((u = 0),
          x.remaining && !0 !== x.remaining && x.remaining--,
          x.remaining
            ? ((o = i),
              I('loopComplete'),
              (x.loopBegan = !1),
              x.direction === 'alternate' && M())
            : ((x.paused = !0),
              x.completed ||
                ((x.completed = !0),
                I('loopComplete'),
                I('complete'),
                !x.passThrough && 'Promise' in window && (s(), f(x)))))
    }
    return (
      (x.reset = function () {
        const n = x.direction
        ;(x.passThrough = !1),
          (x.currentTime = 0),
          (x.progress = 0),
          (x.paused = !0),
          (x.began = !1),
          (x.loopBegan = !1),
          (x.changeBegan = !1),
          (x.completed = !1),
          (x.changeCompleted = !1),
          (x.reversePlayback = !1),
          (x.reversed = n === 'reverse'),
          (x.remaining = x.loop),
          (t = x.children)
        for (let e = (c = t.length); e--; ) x.children[e].reset()
        ;((x.reversed && !0 !== x.loop) ||
          (n === 'alternate' && x.loop === 1)) &&
          x.remaining++,
          P(x.reversed ? x.duration : 0)
      }),
      (x.set = function (n, e) {
        return R(n, e), x
      }),
      (x.tick = function (n) {
        ;(i = n), o || (o = i), T((i + (u - o)) * rn.speed)
      }),
      (x.seek = function (n) {
        T(O(n))
      }),
      (x.pause = function () {
        ;(x.paused = !0), C()
      }),
      (x.play = function () {
        x.paused &&
          (x.completed && x.reset(), (x.paused = !1), _.push(x), C(), U || en())
      }),
      (x.reverse = function () {
        M(), (x.completed = !x.reversed), C()
      }),
      (x.restart = function () {
        x.reset(), x.play()
      }),
      x.reset(),
      x.autoplay && x.play(),
      x
    )
  }
  function tn(n, e) {
    for (let r = e.length; r--; ) x(n, e[r].animatable.target) && e.splice(r, 1)
  }
  return (
    typeof document !== 'undefined' &&
      document.addEventListener('visibilitychange', function () {
        document.hidden
          ? (_.forEach(function (n) {
              return n.pause()
            }),
            (nn = _.slice(0)),
            (rn.running = _ = []))
          : nn.forEach(function (n) {
              return n.play()
            })
      }),
    (rn.version = '3.2.0'),
    (rn.speed = 1),
    (rn.running = _),
    (rn.remove = function (n) {
      for (let e = Z(n), r = _.length; r--; ) {
        const t = _[r]
        const a = t.animations
        const o = t.children
        tn(e, a)
        for (let u = o.length; u--; ) {
          const i = o[u]
          const c = i.animations
          tn(e, c), c.length || i.children.length || o.splice(u, 1)
        }
        a.length || o.length || t.pause()
      }
    }),
    (rn.get = N),
    (rn.set = R),
    (rn.convertPx = I),
    (rn.path = function (n, e) {
      const r = i.str(n) ? g(n)[0] : n
      const t = e || 100
      return function (n) {
        return { property: n, el: r, svg: $(r), totalLength: q(r) * (t / 100) }
      }
    }),
    (rn.setDashoffset = function (n) {
      const e = q(n)
      return n.setAttribute('stroke-dasharray', e), e
    }),
    (rn.stagger = function (n, e) {
      void 0 === e && (e = {})
      const r = e.direction || 'normal'
      const t = e.easing ? v(e.easing) : null
      const a = e.grid
      const o = e.axis
      let u = e.from || 0
      const c = u === 'first'
      const s = u === 'center'
      const f = u === 'last'
      const l = i.arr(n)
      const d = l ? parseFloat(n[0]) : parseFloat(n)
      const p = l ? parseFloat(n[1]) : 0
      const h = C(l ? n[1] : n) || 0
      const g = e.start || 0 + (l ? d : 0)
      let m = []
      let y = 0
      return function (n, e, i) {
        if (
          (c && (u = 0), s && (u = (i - 1) / 2), f && (u = i - 1), !m.length)
        ) {
          for (let v = 0; v < i; v++) {
            if (a) {
              const b = s ? (a[0] - 1) / 2 : u % a[0]
              const x = s ? (a[1] - 1) / 2 : Math.floor(u / a[0])
              const M = b - (v % a[0])
              const w = x - Math.floor(v / a[0])
              let k = Math.sqrt(M * M + w * w)
              o === 'x' && (k = -M), o === 'y' && (k = -w), m.push(k)
            } else m.push(Math.abs(u - v))
            y = Math.max.apply(Math, m)
          }
          t &&
            (m = m.map(function (n) {
              return t(n / y) * y
            })),
            r === 'reverse' &&
              (m = m.map(function (n) {
                return o ? (n < 0 ? -1 * n : -n) : Math.abs(y - n)
              }))
        }
        return g + (l ? (p - d) / y : d) * (Math.round(100 * m[e]) / 100) + h
      }
    }),
    (rn.timeline = function (n) {
      void 0 === n && (n = {})
      const r = rn(n)
      return (
        (r.duration = 0),
        (r.add = function (t, a) {
          const o = _.indexOf(r)
          const u = r.children
          function c(n) {
            n.passThrough = !0
          }
          o > -1 && _.splice(o, 1)
          for (let s = 0; s < u.length; s++) c(u[s])
          const f = k(t, w(e, n))
          f.targets = f.targets || n.targets
          const l = r.duration
          ;(f.autoplay = !1),
            (f.direction = r.direction),
            (f.timelineOffset = i.und(a) ? l : A(a, l)),
            c(r),
            r.seek(f.timelineOffset)
          const d = rn(f)
          c(d), u.push(d)
          const p = J(u, n)
          return (
            (r.delay = p.delay),
            (r.endDelay = p.endDelay),
            (r.duration = p.duration),
            r.seek(0),
            r.reset(),
            r.autoplay && r.play(),
            r
          )
        }),
        r
      )
    }),
    (rn.easing = v),
    (rn.penner = h),
    (rn.random = function (n, e) {
      return Math.floor(Math.random() * (e - n + 1)) + n
    }),
    rn
  )
})
